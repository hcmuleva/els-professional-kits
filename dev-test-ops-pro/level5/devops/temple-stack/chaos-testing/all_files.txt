--- FILE: ./CHAOS_TESTING_README.md ---
# ğŸ”¥ Istio Chaos Testing for Temple API

Complete chaos engineering setup for testing temple-api resilience with configurable failure rates.

## ğŸ“‹ What You Get

- **60% Failure Rate** by default (configurable via ConfigMap)
- **40% Success Rate** (adjustable)
- **Externalizable Parameters** - change without code deployment
- **No Downtime Changes** - update chaos parameters on-the-fly
- **Visual Monitoring** via Kiali, Grafana, and Jaeger
- **Automated Testing** scripts included

---

## ğŸš€ Quick Start (5 Minutes)

### One-Command Setup

```bash
# Make script executable
chmod +x quick-setup-chaos.sh

# Run setup
./quick-setup-chaos.sh
```

This will:
1. âœ… Enable Istio injection
2. âœ… Restart pods with sidecars
3. âœ… Apply chaos configuration
4. âœ… Run initial tests
5. âœ… Display access information

---

## ğŸ“ Files Overview

```
chaos-testing/
â”œâ”€â”€ istio-chaos-config.yaml      # Chaos configuration (VirtualService, DestinationRule, etc.)
â”œâ”€â”€ chaos-controller.sh          # Script to update chaos parameters
â”œâ”€â”€ test-chaos.sh               # Automated testing script
â”œâ”€â”€ quick-setup-chaos.sh        # One-click setup script
â”œâ”€â”€ Chaos-Makefile              # Convenient make commands
â””â”€â”€ ISTIO_CHAOS_SETUP.md        # Detailed documentation
```

---

## ğŸ¯ Usage Examples

### Change Failure Rate

```bash
# Method 1: Using Makefile (Easiest)
make set-chaos-80    # 80% failure
make set-chaos-30    # 30% failure
make set-chaos-0     # Disable chaos

# Method 2: Edit ConfigMap
kubectl edit configmap temple-api-chaos-config -n temple-stack
# Change failure-percent to desired value
./chaos-controller.sh

# Method 3: Using kubectl patch
kubectl patch configmap temple-api-chaos-config -n temple-stack \
  --type merge -p '{"data":{"failure-percent":"70","success-percent":"30"}}'
./chaos-controller.sh
```

### Run Tests

```bash
# Quick test (10 requests)
make test-chaos-quick

# Full test (100 requests)
make test-chaos

# Custom number of requests
./test-chaos.sh 500
```

### Monitor Traffic

```bash
# Open Kiali (visual service mesh)
make kiali
# Access at: http://localhost:20001

# Open Grafana (metrics)
make grafana
# Access at: http://localhost:3000

# Open Jaeger (tracing)
make jaeger
# Access at: http://localhost:16686
```

### View Logs

```bash
# Istio proxy logs (see traffic routing)
make logs-proxy

# Application logs
make logs-app

# Watch traffic in real-time
make watch-traffic
```

---

## ğŸ® Makefile Commands

```bash
make help              # Show all commands

# Setup
make setup             # Complete setup
make enable-istio      # Enable Istio injection
make apply-chaos       # Apply chaos config

# Testing
make test-chaos        # Run 100-request test
make test-chaos-quick  # Run 10-request test
make test-health       # Test health endpoint

# Change Chaos Levels
make set-chaos-60      # 60% failure (default)
make set-chaos-80      # 80% failure
make set-chaos-30      # 30% failure
make set-chaos-0       # Disable chaos

# Monitoring
make status            # Show current configuration
make kiali             # Open Kiali dashboard
make grafana           # Open Grafana
make jaeger            # Open Jaeger

# Cleanup
make remove-chaos      # Remove chaos config
make disable-istio     # Disable Istio
make clean             # Complete cleanup
```

---

## ğŸ“Š Understanding the Results

### Test Output Example

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     Test Results                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Summary:
  Total Requests:    100
  Successful:        42 (42%)
  Failed:            58 (58%)

Status Code Distribution:
  200: 42 requests (42%)
  503: 58 requests (58%)

Expected vs Actual:
  Success Rate:   âœ“ Within tolerance (Expected: 40%, Actual: 42%)
  Failure Rate:   âœ“ Within tolerance (Expected: 60%, Actual: 58%)

Visual Distribution:
  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]
   ^^^^^^^^^^^^^^^^^^^^^^^ Success (green)
                           ^^^^^^^^^^^^^^^^^^^^^^^^ Failure (red)
```

---

## ğŸ”§ Configuration Details

### Current Setup

**Default Configuration:**
- **Failure Rate:** 60%
- **Success Rate:** 40%
- **Failure Status Code:** 503 (Service Unavailable)
- **Scope:** All `/api/*` paths
- **Exception:** `/_health` endpoint (never fails)

### ConfigMap Structure

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: temple-api-chaos-config
  namespace: temple-stack
data:
  failure-percent: "60"    # Percentage of requests that fail
  success-percent: "40"    # Percentage of requests that succeed
  failure-status: "503"    # HTTP status code for failures
```

### How It Works

1. **VirtualService** intercepts traffic to temple-api
2. **Fault Injection** randomly fails requests based on percentage
3. **ConfigMap** stores parameters externally
4. **chaos-controller.sh** applies ConfigMap values to VirtualService
5. **No pod restart needed** - changes apply immediately

---

## ğŸ¨ Kiali Visualization

After running `make kiali`, you'll see:

### Service Graph View
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Ingress    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  temple-api  â”‚â—„â”€â”€ 60% RED (failed)
â”‚   Service    â”‚â—„â”€â”€ 40% GREEN (success)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PostgreSQL  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Traffic Metrics
- **Request Volume:** Shows total RPS
- **Success Rate:** Visual percentage
- **Response Time:** P50, P95, P99
- **Error Rate:** Highlighted in red

---

## ğŸ§ª Advanced Scenarios

### Scenario 1: Gradual Failure Increase

```bash
# Start with low failure rate
make set-chaos-30
make test-chaos

# Increase gradually
make set-chaos-50
make test-chaos

# High failure rate
make set-chaos-80
make test-chaos
```

### Scenario 2: Add Delay Instead of Failures

Edit `istio-chaos-config.yaml`:

```yaml
fault:
  delay:
    percentage:
      value: 60.0
    fixedDelay: 3s  # 3 second delay on 60% of requests
```

Apply:
```bash
kubectl apply -f istio-chaos-config.yaml
```

### Scenario 3: Path-Specific Chaos

Different failure rates for different endpoints:

```yaml
http:
- match:
  - uri:
      prefix: /api/users
  fault:
    abort:
      percentage:
        value: 80.0  # 80% failure for /users
      httpStatus: 503
- match:
  - uri:
      prefix: /api/posts
  fault:
    abort:
      percentage:
        value: 20.0  # 20% failure for /posts
      httpStatus: 503
```

---

## ğŸ› Troubleshooting

### Problem: Chaos Not Working (All Requests Succeed)

**Check 1: Verify Istio Sidecars**
```bash
kubectl get pods -n temple-stack
# Should show 2/2 for temple-api
```

**Check 2: Verify VirtualService**
```bash
make describe-vs
# Check fault.abort.percentage.value
```

**Check 3: Test Directly**
```bash
for i in {1..20}; do
  curl -s -o /dev/null -w "Status: %{http_code}\n" http://temple-api.local/api/users
done
```

---

### Problem: All Requests Fail

**Solution 1: Check Configuration**
```bash
make status
# Verify failure-percent isn't 100
```

**Solution 2: Temporarily Disable Chaos**
```bash
make set-chaos-0
make test-chaos-quick
```

---

### Problem: Can't Access temple-api.local

**Solution: Update /etc/hosts**
```bash
echo "127.0.0.1 temple-api.local" | sudo tee -a /etc/hosts
echo "127.0.0.1 temple-ui.local" | sudo tee -a /etc/hosts
```

**Test Connection:**
```bash
ping temple-api.local
curl http://temple-api.local/_health
```

---

### Problem: Istio Sidecar Not Injected

**Solution: Re-enable and Restart**
```bash
# Re-label namespace
kubectl label namespace temple-stack istio-injection=enabled --overwrite

# Force restart
kubectl delete pod -n temple-stack -l app=temple-api
kubectl delete pod -n temple-stack -l app=temple-ui

# Wait for pods
kubectl wait --for=condition=ready pod -n temple-stack -l app=temple-api --timeout=5m
```

---

## ğŸ“ˆ Metrics and Observability

### Key Metrics to Monitor

**In Grafana:**
1. **Request Rate:** Total requests/second
2. **Success Rate:** Percentage of 2xx responses
3. **Error Rate:** Percentage of 5xx responses
4. **Latency:** P50, P95, P99 response times
5. **Retry Rate:** How often clients retry

**In Kiali:**
1. **Service Graph:** Visual representation of traffic
2. **Traffic Distribution:** Request flow percentages
3. **Health Status:** Service health indicators
4. **Configuration:** VirtualService and DestinationRule status

**In Jaeger:**
1. **Trace Duration:** End-to-end request time
2. **Span Details:** Individual service call times
3. **Error Traces:** Failed request paths
4. **Dependency Graph:** Service dependencies

---

## ğŸ“ Learning Objectives

This chaos testing setup helps you learn:

### 1. **Resilience Patterns**
- How services handle failures
- Circuit breaker behavior
- Retry mechanisms
- Fallback strategies

### 2. **Observability**
- Distributed tracing with Jaeger
- Metrics visualization with Grafana
- Service mesh visualization with Kiali
- Log aggregation and analysis

### 3. **Istio Features**
- Traffic management
- Fault injection
- Virtual services
- Destination rules
- Service mesh capabilities

### 4. **Testing Strategies**
- Chaos engineering principles
- Failure injection techniques
- Progressive testing approach
- Metrics-driven validation

---

## ğŸš¦ Best Practices

### 1. **Start Small**
```bash
# Begin with low failure rates
make set-chaos-30
make test-chaos

# Gradually increase
make set-chaos-60
make test-chaos

# Test extremes
make set-chaos-80
make test-chaos
```

### 2. **Monitor Continuously**
```bash
# Keep Kiali open while testing
make kiali

# Watch logs in another terminal
make logs-proxy
```

### 3. **Test Incrementally**
```bash
# Quick validation
make test-chaos-quick

# Full test after validation
make test-chaos

# Extended test for statistics
./test-chaos.sh 1000
```

### 4. **Document Results**
```bash
# Test results are auto-saved
ls -la chaos-test-results-*.txt

# Review results
cat chaos-test-results-*.txt
```

### 5. **Clean Up After Testing**
```bash
# Disable chaos when not testing
make set-chaos-0

# Or remove completely
make remove-chaos
```

---

## ğŸ“Š Sample Test Scenarios

### Scenario 1: Basic Resilience Test
```bash
# Test with default 60% failure
make test-chaos

# Expected: Application handles failures gracefully
# UI should show error messages, not crash
```

### Scenario 2: High Load + Chaos
```bash
# Terminal 1: Generate load
while true; do curl http://temple-api.local/api/users; sleep 0.1; done

# Terminal 2: Monitor
make kiali

# Terminal 3: Increase chaos
make set-chaos-80
```

### Scenario 3: Recovery Test
```bash
# Start with high failure
make set-chaos-90
make test-chaos

# Gradually recover
make set-chaos-60
make test-chaos

make set-chaos-30
make test-chaos

make set-chaos-0
make test-chaos
```

### Scenario 4: Weekend Load Test
```bash
# Friday afternoon: Enable chaos
make set-chaos-40

# Monitor over weekend
make status

# Monday morning: Review results and disable
cat chaos-test-results-*.txt
make set-chaos-0
```

---

## ğŸ” Security Considerations

### 1. **Namespace Isolation**
- Chaos only affects `temple-stack` namespace
- Other namespaces are unaffected
- Network policies can add extra isolation

### 2. **Health Check Exemption**
```yaml
# Health checks never fail
- match:
  - uri:
      prefix: /_health
  # No fault injection
  route:
  - destination:
      host: temple-api-service
```

### 3. **Production Safeguards**
```bash
# Never enable in production accidentally
# Add namespace check to scripts:
if [ "$NAMESPACE" == "production" ]; then
  echo "ERROR: Cannot enable chaos in production"
  exit 1
fi
```

---

## ğŸ“š Additional Resources

### Istio Documentation
- [Traffic Management](https://istio.io/latest/docs/concepts/traffic-management/)
- [Fault Injection](https://istio.io/latest/docs/tasks/traffic-management/fault-injection/)
- [Observability](https://istio.io/latest/docs/tasks/observability/)

### Chaos Engineering
- [Principles of Chaos Engineering](https://principlesofchaos.org/)
- [Chaos Engineering Book](https://www.oreilly.com/library/view/chaos-engineering/9781491988459/)
- [Netflix Chaos Monkey](https://netflix.github.io/chaosmonkey/)

### Tools
- [Kiali Documentation](https://kiali.io/docs/)
- [Grafana Dashboard](https://grafana.com/docs/)
- [Jaeger Tracing](https://www.jaegertracing.io/docs/)

---

## ğŸ¯ Success Checklist

After setup, verify:

- [ ] Pods show `2/2` containers (app + istio-proxy)
- [ ] VirtualService is created and configured
- [ ] ConfigMap contains correct percentages
- [ ] Health check endpoint always succeeds
- [ ] Test script shows expected failure rate
- [ ] Kiali displays traffic with errors
- [ ] Grafana shows error rate metrics
- [ ] /etc/hosts has temple-api.local entry
- [ ] Can change failure rate without restart
- [ ] chaos-controller.sh updates successfully

---

## ğŸ§¹ Cleanup

### Temporary Disable
```bash
# Keep infrastructure, just disable chaos
make set-chaos-0
```

### Remove Chaos Config
```bash
# Remove chaos but keep Istio
make remove-chaos
```

### Complete Cleanup
```bash
# Remove chaos and disable Istio
make clean
```

### Manual Cleanup
```bash
# Delete chaos resources
kubectl delete virtualservice temple-api-chaos -n temple-stack
kubectl delete destinationrule temple-api-chaos -n temple-stack
kubectl delete gateway temple-api-gateway -n temple-stack
kubectl delete configmap temple-api-chaos-config -n temple-stack

# Remove Istio label
kubectl label namespace temple-stack istio-injection-

# Restart pods
kubectl rollout restart deployment/temple-api -n temple-stack
kubectl rollout restart deployment/temple-ui -n temple-stack
```

---

## ğŸ¤ Support

### Getting Help

**Check Status:**
```bash
make status
```

**View Logs:**
```bash
make logs-proxy  # Istio routing logs
make logs-app    # Application logs
```

**Describe Resources:**
```bash
make describe-vs  # VirtualService details
make describe-dr  # DestinationRule details
```

**Community Resources:**
- Istio Slack: slack.istio.io
- Istio GitHub: github.com/istio/istio
- Stack Overflow: [istio] tag

---

## ğŸ“ Common Questions

### Q: Why 60% failure rate?
**A:** Industry standard for chaos testing. Enough to expose issues but not overwhelming. Adjustable based on your needs.

### Q: Does this affect production?
**A:** Only if you deploy to production namespace. Recommended for dev/staging only.

### Q: Can I test specific endpoints?
**A:** Yes! Modify the VirtualService to target specific paths with different failure rates.

### Q: How do I test UI resilience?
**A:** Open http://temple-ui.local and interact while chaos is enabled. UI should handle API errors gracefully.

### Q: Can I schedule chaos tests?
**A:** Yes! Use a CronJob to enable/disable chaos at specific times.

### Q: Does this slow down my services?
**A:** Minimal overhead from Istio proxy. Failed requests are faster (immediate 503) than successful ones.

---

## ğŸ‰ What's Next?

### Level 1: Basic Chaos âœ…
- [x] Enable Istio
- [x] Apply fault injection
- [x] Run basic tests

### Level 2: Advanced Chaos
- [ ] Add delay injection
- [ ] Test different paths
- [ ] Circuit breaker configuration
- [ ] Retry policies

### Level 3: Automated Chaos
- [ ] CI/CD integration
- [ ] Scheduled chaos tests
- [ ] Automated metrics collection
- [ ] Alert on failure patterns

### Level 4: Production Chaos
- [ ] Gradual rollout strategy
- [ ] Percentage-based targeting
- [ ] Automated rollback
- [ ] Incident simulation

---

## ğŸ’¡ Pro Tips

1. **Always test health checks first**
   ```bash
   make test-health
   ```

2. **Use Kiali for visual debugging**
   ```bash
   make kiali
   ```

3. **Save test results for analysis**
   ```bash
   ./test-chaos.sh 1000 > results.txt
   ```

4. **Monitor during changes**
   ```bash
   # Terminal 1
   make kiali
   
   # Terminal 2
   make set-chaos-80
   ```

5. **Test during low traffic**
   - Easier to see patterns
   - Less impact if issues arise

---

## ğŸ“ Quick Reference Card

```bash
# Setup
./quick-setup-chaos.sh

# Change failure rates
make set-chaos-{0,30,60,80}

# Test
make test-chaos

# Monitor
make kiali

# Status
make status

# Cleanup
make clean

# Help
make help
```

---

**Version:** 1.0.0  
**Last Updated:** 2024  
**Status:** Production Ready âœ…

---

Happy Chaos Testing! ğŸ”¥ğŸ§ª
--- FILE: ./Makefile ---
# Istio Chaos Testing Makefile for Temple API

.PHONY: help setup enable-istio apply-chaos test-chaos update-chaos remove-chaos status monitor

# Colors
BLUE := \033[0;34m
GREEN := \033[0;32m
YELLOW := \033[1;33m
NC := \033[0m

NAMESPACE := temple-stack

help: ## Show this help message
	@echo "$(BLUE)Istio Chaos Testing - Available Commands$(NC)"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  $(GREEN)%-25s$(NC) %s\n", $$1, $$2}'
	@echo ""

setup: enable-istio restart-pods wait-ready ## Complete setup (enable Istio, restart pods, wait for ready)

enable-istio: ## Enable Istio injection for temple-stack namespace
	@echo "$(BLUE)Enabling Istio injection for namespace $(NAMESPACE)...$(NC)"
	kubectl label namespace $(NAMESPACE) istio-injection=enabled --overwrite
	@echo "$(GREEN)âœ… Istio injection enabled$(NC)"

restart-pods: ## Restart pods to inject Istio sidecars
	@echo "$(BLUE)Restarting deployments to inject Istio sidecars...$(NC)"
	kubectl rollout restart deployment/temple-api -n $(NAMESPACE)
	kubectl rollout restart deployment/temple-ui -n $(NAMESPACE)
	@echo "$(GREEN)âœ… Deployments restarted$(NC)"

wait-ready: ## Wait for pods to be ready
	@echo "$(BLUE)Waiting for pods to be ready...$(NC)"
	kubectl rollout status deployment/temple-api -n $(NAMESPACE)
	kubectl rollout status deployment/temple-ui -n $(NAMESPACE)
	@echo "$(GREEN)âœ… All pods ready$(NC)"

verify-sidecars: ## Verify Istio sidecars are injected
	@echo "$(BLUE)Verifying Istio sidecars...$(NC)"
	@kubectl get pods -n $(NAMESPACE) -o=custom-columns=NAME:.metadata.name,READY:.status.containerStatuses[*].ready
	@echo ""
	@echo "$(YELLOW)Note: Should see 2/2 for temple-api and temple-ui$(NC)"

apply-chaos: ## Apply chaos configuration
	@echo "$(BLUE)Applying chaos configuration...$(NC)"
	kubectl apply -f istio-chaos-config.yaml
	@echo "$(GREEN)âœ… Chaos configuration applied$(NC)"

update-chaos: ## Update chaos parameters (run chaos-controller.sh)
	@echo "$(BLUE)Updating chaos parameters...$(NC)"
	./chaos-controller.sh

set-chaos-60: ## Set chaos to 60% failure (quick preset)
	@echo "$(BLUE)Setting chaos to 60% failure...$(NC)"
	kubectl patch configmap temple-api-chaos-config -n $(NAMESPACE) --type merge -p '{"data":{"failure-percent":"60","success-percent":"40"}}'
	./chaos-controller.sh
	@echo "$(GREEN)âœ… Chaos set to 60% failure$(NC)"

set-chaos-80: ## Set chaos to 80% failure (quick preset)
	@echo "$(BLUE)Setting chaos to 80% failure...$(NC)"
	kubectl patch configmap temple-api-chaos-config -n $(NAMESPACE) --type merge -p '{"data":{"failure-percent":"80","success-percent":"20"}}'
	./chaos-controller.sh
	@echo "$(GREEN)âœ… Chaos set to 80% failure$(NC)"

set-chaos-30: ## Set chaos to 30% failure (quick preset)
	@echo "$(BLUE)Setting chaos to 30% failure...$(NC)"
	kubectl patch configmap temple-api-chaos-config -n $(NAMESPACE) --type merge -p '{"data":{"failure-percent":"30","success-percent":"70"}}'
	./chaos-controller.sh
	@echo "$(GREEN)âœ… Chaos set to 30% failure$(NC)"

set-chaos-0: ## Disable chaos (0% failure)
	@echo "$(BLUE)Disabling chaos...$(NC)"
	kubectl patch configmap temple-api-chaos-config -n $(NAMESPACE) --type merge -p '{"data":{"failure-percent":"0","success-percent":"100"}}'
	./chaos-controller.sh
	@echo "$(GREEN)âœ… Chaos disabled$(NC)"

test-chaos: ## Run chaos test (100 requests)
	@echo "$(BLUE)Running chaos test (100 requests)...$(NC)"
	@./test-chaos.sh

test-chaos-quick: ## Quick chaos test (10 requests)
	@echo "$(BLUE)Running quick chaos test...$(NC)"
	@for i in {1..10}; do \
		STATUS=$$(curl -s -o /dev/null -w "%{http_code}" http://temple-api.local/api/users); \
		if [ "$$STATUS" == "200" ]; then \
			echo "Request $$i: âœ… Success ($$STATUS)"; \
		else \
			echo "Request $$i: âŒ Failed ($$STATUS)"; \
		fi; \
		sleep 0.3; \
	done

test-health: ## Test health endpoint (should never fail)
	@echo "$(BLUE)Testing health endpoint...$(NC)"
	@curl -s http://temple-api.local/_health | jq . || echo "Health check OK"

status: ## Show chaos status
	@echo "$(BLUE)Chaos Configuration Status:$(NC)"
	@echo ""
	@echo "ConfigMap:"
	@kubectl get configmap temple-api-chaos-config -n $(NAMESPACE) -o json | jq -r '.data | to_entries[] | "\(.key): \(.value)"'
	@echo ""
	@echo "VirtualService:"
	@kubectl get virtualservice temple-api-chaos -n $(NAMESPACE) -o json | jq -r '.spec.http[0].fault.abort.percentage.value' | xargs -I {} echo "Failure Rate: {}%"
	@echo ""
	@echo "Pods with Sidecars:"
	@kubectl get pods -n $(NAMESPACE) -o wide

list-resources: ## List all chaos-related resources
	@echo "$(BLUE)Chaos Resources:$(NC)"
	@kubectl get virtualservice,destinationrule,gateway,configmap -n $(NAMESPACE) | grep chaos

remove-chaos: ## Remove chaos configuration
	@echo "$(BLUE)Removing chaos configuration...$(NC)"
	kubectl delete virtualservice temple-api-chaos -n $(NAMESPACE) --ignore-not-found
	kubectl delete destinationrule temple-api-chaos -n $(NAMESPACE) --ignore-not-found
	kubectl delete gateway temple-api-gateway -n $(NAMESPACE) --ignore-not-found
	kubectl delete configmap temple-api-chaos-config -n $(NAMESPACE) --ignore-not-found
	@echo "$(GREEN)âœ… Chaos configuration removed$(NC)"

disable-istio: ## Disable Istio injection and restart pods
	@echo "$(BLUE)Disabling Istio injection...$(NC)"
	kubectl label namespace $(NAMESPACE) istio-injection-
	kubectl rollout restart deployment/temple-api -n $(NAMESPACE)
	kubectl rollout restart deployment/temple-ui -n $(NAMESPACE)
	kubectl rollout status deployment/temple-api -n $(NAMESPACE)
	kubectl rollout status deployment/temple-ui -n $(NAMESPACE)
	@echo "$(GREEN)âœ… Istio disabled$(NC)"

logs-proxy: ## Show Istio proxy logs for temple-api
	kubectl logs -n $(NAMESPACE) deployment/temple-api -c istio-proxy -f

logs-app: ## Show application logs for temple-api
	kubectl logs -n $(NAMESPACE) deployment/temple-api -c temple-api -f

kiali: ## Open Kiali dashboard
	@echo "$(BLUE)Opening Kiali dashboard...$(NC)"
	@echo "Access at: http://localhost:20001"
	kubectl port-forward svc/kiali -n istio-system 20001:20001

grafana: ## Open Grafana dashboard
	@echo "$(BLUE)Opening Grafana dashboard...$(NC)"
	@echo "Access at: http://localhost:3000"
	@echo "Default credentials: admin/admin"
	kubectl port-forward svc/grafana -n istio-system 3000:3000

jaeger: ## Open Jaeger tracing UI
	@echo "$(BLUE)Opening Jaeger UI...$(NC)"
	@echo "Access at: http://localhost:16686"
	kubectl port-forward svc/tracing -n istio-system 16686:80

monitor: ## Open all monitoring dashboards (requires multiple terminals)
	@echo "$(BLUE)To open all monitoring tools, run these in separate terminals:$(NC)"
	@echo "  make kiali"
	@echo "  make grafana"
	@echo "  make jaeger"

describe-vs: ## Describe VirtualService
	kubectl describe virtualservice temple-api-chaos -n $(NAMESPACE)

describe-dr: ## Describe DestinationRule
	kubectl describe destinationrule temple-api-chaos -n $(NAMESPACE)

edit-config: ## Edit chaos ConfigMap
	kubectl edit configmap temple-api-chaos-config -n $(NAMESPACE)

watch-pods: ## Watch pod status
	watch kubectl get pods -n $(NAMESPACE)

watch-traffic: ## Watch istio-proxy access logs
	kubectl logs -n $(NAMESPACE) deployment/temple-api -c istio-proxy -f | grep -E "HTTP|503"

demo: ## Run complete demo (setup, test, show results)
	@echo "$(BLUE)â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—$(NC)"
	@echo "$(BLUE)â•‘           Istio Chaos Testing Demo                          â•‘$(NC)"
	@echo "$(BLUE)â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•$(NC)"
	@echo ""
	@echo "$(YELLOW)Step 1: Enabling Istio...$(NC)"
	@make enable-istio
	@echo ""
	@echo "$(YELLOW)Step 2: Restarting pods...$(NC)"
	@make restart-pods
	@echo ""
	@echo "$(YELLOW)Step 3: Waiting for pods to be ready...$(NC)"
	@make wait-ready
	@echo ""
	@echo "$(YELLOW)Step 4: Verifying sidecars...$(NC)"
	@make verify-sidecars
	@echo ""
	@echo "$(YELLOW)Step 5: Applying chaos configuration...$(NC)"
	@make apply-chaos
	@echo ""
	@echo "$(YELLOW)Step 6: Setting chaos to 60% failure...$(NC)"
	@make set-chaos-60
	@echo ""
	@echo "$(YELLOW)Step 7: Running chaos test...$(NC)"
	@make test-chaos
	@echo ""
	@echo "$(GREEN)â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—$(NC)"
	@echo "$(GREEN)â•‘              Demo Complete!                                  â•‘$(NC)"
	@echo "$(GREEN)â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•$(NC)"
	@echo ""
	@echo "$(BLUE)Next steps:$(NC)"
	@echo "  - Run: make kiali     (to view traffic in Kiali)"
	@echo "  - Run: make grafana   (to view metrics)"
	@echo "  - Run: make set-chaos-80  (to change failure rate)"
	@echo "  - Run: make test-chaos    (to run more tests)"

clean: remove-chaos disable-istio ## Complete cleanup (remove chaos and disable Istio)
	@echo "$(GREEN)âœ… Complete cleanup done$(NC)"
--- FILE: ./chaos-controller.sh ---
#!/bin/bash

# ============================================
# Istio Chaos Controller for Temple API
# ============================================
# This script reads chaos parameters from ConfigMap
# and updates the VirtualService accordingly

set -e

NAMESPACE="temple-stack"
CONFIGMAP="temple-api-chaos-config"
VIRTUALSERVICE="temple-api-chaos"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

print_info() { echo -e "${BLUE}â„¹ï¸  $1${NC}"; }
print_success() { echo -e "${GREEN}âœ… $1${NC}"; }
print_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
print_error() { echo -e "${RED}âŒ $1${NC}"; }

# Get current chaos parameters
get_chaos_params() {
    FAILURE_PERCENT=$(kubectl get configmap $CONFIGMAP -n $NAMESPACE -o jsonpath='{.data.failure-percent}')
    FAILURE_STATUS=$(kubectl get configmap $CONFIGMAP -n $NAMESPACE -o jsonpath='{.data.failure-status}')
    SUCCESS_PERCENT=$(kubectl get configmap $CONFIGMAP -n $NAMESPACE -o jsonpath='{.data.success-percent}')
    
    print_info "Current Chaos Configuration:"
    echo "  Failure Rate: ${FAILURE_PERCENT}%"
    echo "  Success Rate: ${SUCCESS_PERCENT}%"
    echo "  Failure Status Code: ${FAILURE_STATUS}"
}

# Update VirtualService with new parameters
update_virtualservice() {
    print_info "Updating VirtualService with new chaos parameters..."
    
    # Create temporary file with updated values
    cat > /tmp/vs-patch.yaml <<EOF
spec:
  hosts:
  - temple-api-service
  - temple-api.local
  http:
  - match:
    - uri:
        prefix: /api
    fault:
      abort:
        percentage:
          value: ${FAILURE_PERCENT}.0
        httpStatus: ${FAILURE_STATUS}
    route:
    - destination:
        host: temple-api-service
        port:
          number: 1337
  - match:
    - uri:
        prefix: /_health
    route:
    - destination:
        host: temple-api-service
        port:
          number: 1337
  - route:
    - destination:
        host: temple-api-service
        port:
          number: 1337
EOF
    
    # Apply the patch
    kubectl patch virtualservice $VIRTUALSERVICE -n $NAMESPACE --type merge --patch-file /tmp/vs-patch.yaml
    
    # Clean up
    rm /tmp/vs-patch.yaml
    
    print_success "VirtualService updated successfully!"
}

# Validate configuration
validate_config() {
    if [ -z "$FAILURE_PERCENT" ] || [ -z "$SUCCESS_PERCENT" ]; then
        print_error "Failed to read chaos parameters from ConfigMap"
        exit 1
    fi
    
    # Check if percentages add up to 100
    TOTAL=$((FAILURE_PERCENT + SUCCESS_PERCENT))
    if [ $TOTAL -ne 100 ]; then
        print_warning "Warning: Failure ($FAILURE_PERCENT%) + Success ($SUCCESS_PERCENT%) = $TOTAL% (should be 100%)"
    fi
}

# Main function
main() {
    echo "============================================"
    echo "  Istio Chaos Controller"
    echo "============================================"
    echo ""
    
    get_chaos_params
    validate_config
    
    echo ""
    read -p "Apply these chaos parameters? [Y/n]: " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]] && [[ ! -z $REPLY ]]; then
        print_info "Operation cancelled"
        exit 0
    fi
    
    update_virtualservice
    
    echo ""
    print_success "Chaos parameters applied successfully!"
    echo ""
    print_info "To test the chaos:"
    echo "  curl http://temple-api.local/api/users"
    echo "  # Expect ${FAILURE_PERCENT}% of requests to fail with 503"
    echo ""
    print_info "To modify parameters:"
    echo "  kubectl edit configmap $CONFIGMAP -n $NAMESPACE"
    echo "  ./chaos-controller.sh  # Re-run this script"
}

# Run main
main
--- FILE: ./istio-chaos-config.yaml ---
# ConfigMap to store chaos parameters
apiVersion: v1
kind: ConfigMap
metadata:
  name: temple-api-chaos-config
  namespace: temple-stack
data:
  # Failure percentage (0-100)
  failure-percent: "60"
  # HTTP status code to return on failure
  failure-status: "503"
  # Delay in milliseconds for failed requests
  failure-delay: "0"
  # Success percentage (should be 100 - failure-percent)
  success-percent: "40"

---
# VirtualService for chaos injection
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: temple-api-chaos
  namespace: temple-stack
spec:
  hosts:
    - temple-api-service
    - temple-api.local
  gateways:
    - temple-api-gateway   # ğŸ‘ˆ critical line to scope only to your API gateway
  http:
    - match:
        - uri:
            prefix: /api
      fault:
        abort:
          percentage:
            value: 60.0
          httpStatus: 503
      route:
        - destination:
            host: temple-api-service
            port:
              number: 1337
    - match:
        - uri:
            prefix: /_health
      route:
        - destination:
            host: temple-api-service
            port:
              number: 1337
    - route:
        - destination:
            host: temple-api-service
            port:
              number: 1337


---
# DestinationRule for traffic policy
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: temple-api-chaos
  namespace: temple-stack
spec:
  host: temple-api-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        http2MaxRequests: 100
    outlierDetection:
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50

---
# Gateway for external access
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: temple-api-gateway
  namespace: temple-stack
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - temple-api.local
--- FILE: ./quick-setup-chaos.sh ---
#!/bin/bash

# ============================================
# Quick Setup Script for Istio Chaos Testing
# ============================================

set -e

NAMESPACE="temple-stack"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_header() {
    echo ""
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘  $1"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

print_info() { echo -e "${BLUE}â„¹ï¸  $1${NC}"; }
print_success() { echo -e "${GREEN}âœ… $1${NC}"; }
print_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
print_error() { echo -e "${RED}âŒ $1${NC}"; }

check_prerequisites() {
    print_header "Checking Prerequisites"
    
    # Check kubectl
    if ! command -v kubectl &> /dev/null; then
        print_error "kubectl not found"
        exit 1
    fi
    print_success "kubectl found"
    
    # Check cluster connection
    if ! kubectl cluster-info &> /dev/null; then
        print_error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
    print_success "Connected to Kubernetes cluster"
    
    # Check Istio
    if ! kubectl get namespace istio-system &> /dev/null; then
        print_error "Istio not installed. Please install Istio first."
        exit 1
    fi
    print_success "Istio is installed"
    
    # Check namespace
    if ! kubectl get namespace $NAMESPACE &> /dev/null; then
        print_error "Namespace $NAMESPACE not found"
        exit 1
    fi
    print_success "Namespace $NAMESPACE exists"
    
    # Check if temple-api exists
    if ! kubectl get deployment temple-api -n $NAMESPACE &> /dev/null; then
        print_error "temple-api deployment not found in $NAMESPACE"
        exit 1
    fi
    print_success "temple-api deployment found"
}

enable_istio_injection() {
    print_header "Enabling Istio Injection"
    
    print_info "Labeling namespace for Istio injection..."
    kubectl label namespace $NAMESPACE istio-injection=enabled --overwrite
    
    print_success "Istio injection enabled for $NAMESPACE"
}

restart_deployments() {
    print_header "Restarting Deployments"
    
    print_info "Restarting temple-api..."
    kubectl rollout restart deployment/temple-api -n $NAMESPACE
    
    print_info "Restarting temple-ui-deployment..."
    kubectl rollout restart deployment/temple-ui-deployment -n $NAMESPACE
    
    print_info "Waiting for rollouts to complete..."
    kubectl rollout status deployment/temple-api -n $NAMESPACE --timeout=5m
    kubectl rollout status deployment/temple-ui-deployment -n $NAMESPACE --timeout=5m
    
    print_success "All deployments restarted with Istio sidecars"
}

verify_sidecars() {
    print_header "Verifying Istio Sidecars"
    
    echo "Pod Status:"
    kubectl get pods -n $NAMESPACE -o custom-columns=NAME:.metadata.name,READY:.status.containerStatuses[*].ready,CONTAINERS:.spec.containers[*].name
    
    echo ""
    
    # Check if pods have 2 containers
    API_CONTAINERS=$(kubectl get pod -n $NAMESPACE -l app=temple-api -o jsonpath='{.items[0].spec.containers[*].name}' | wc -w)
    
    if [ "$API_CONTAINERS" -eq 2 ]; then
        print_success "temple-api has Istio sidecar (2 containers)"
    else
        print_warning "temple-api may not have Istio sidecar (only $API_CONTAINERS container(s))"
    fi
}

apply_chaos_config() {
    print_header "Applying Chaos Configuration"
    
    if [ ! -f "istio-chaos-config.yaml" ]; then
        print_error "istio-chaos-config.yaml not found"
        print_info "Please ensure all required files are in the current directory"
        exit 1
    fi
    
    print_info "Applying chaos resources..."
    kubectl apply -f istio-chaos-config.yaml
    
    print_success "Chaos configuration applied"
    
    echo ""
    print_info "Resources created:"
    kubectl get virtualservice,destinationrule,gateway,configmap -n $NAMESPACE | grep chaos || true
}

make_scripts_executable() {
    print_header "Setting Up Scripts"
    
    if [ -f "chaos-controller.sh" ]; then
        chmod +x chaos-controller.sh
        print_success "chaos-controller.sh is executable"
    fi
    
    if [ -f "test-chaos.sh" ]; then
        chmod +x test-chaos.sh
        print_success "test-chaos.sh is executable"
    fi
}

update_etc_hosts() {
    print_header "Updating /etc/hosts"
    
    if grep -q "temple-api.local" /etc/hosts && grep -q "temple-ui.local" /etc/hosts; then
        print_info "/etc/hosts already contains required entries"
    else
        print_warning "You need to add these entries to /etc/hosts:"
        echo ""
        echo "127.0.0.1 temple-api.local"
        echo "127.0.0.1 temple-ui.local"
        echo ""
        
        read -p "Add them now? (requires sudo) [y/N]: " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            if ! grep -q "temple-api.local" /etc/hosts; then
                echo "127.0.0.1 temple-api.local" | sudo tee -a /etc/hosts > /dev/null
            fi
            if ! grep -q "temple-ui.local" /etc/hosts; then
                echo "127.0.0.1 temple-ui.local" | sudo tee -a /etc/hosts > /dev/null
            fi
            print_success "/etc/hosts updated"
        else
            print_warning "Please add entries manually to /etc/hosts"
        fi
    fi
}

run_initial_test() {
    print_header "Running Initial Chaos Test"
    
    print_info "Testing with 10 requests..."
    echo ""
    
    for i in {1..10}; do
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://temple-api.local/api/users 2>/dev/null || echo "000")
        
        if [ "$STATUS" == "200" ]; then
            echo -e "Request $i: ${GREEN}âœ“ Success ($STATUS)${NC}"
        else
            echo -e "Request $i: ${RED}âœ— Failed ($STATUS)${NC}"
        fi
        sleep 0.3
    done
    
    echo ""
    print_info "For detailed testing, run: ./test-chaos.sh"
}

show_summary() {
    print_header "Setup Complete!"
    
    echo -e "${GREEN}âœ… Istio chaos testing is now configured!${NC}"
    echo ""
    
    echo -e "${BLUE}Quick Commands:${NC}"
    echo ""
    echo "  # Run chaos test"
    echo "  ./test-chaos.sh"
    echo ""
    echo "  # Change failure rate to 80%"
    echo "  make set-chaos-80"
    echo ""
    echo "  # View current configuration"
    echo "  make status"
    echo ""
    echo "  # Open Kiali dashboard"
    echo "  make kiali"
    echo ""
    echo "  # See all available commands"
    echo "  make help"
    echo ""
    
    echo -e "${BLUE}Access URLs:${NC}"
    echo "  Frontend:     http://temple-ui.local"
    echo "  API:          http://temple-api.local/api"
    echo "  Health Check: http://temple-api.local/_health"
    echo ""
    
    echo -e "${BLUE}Current Chaos Configuration:${NC}"
    FAILURE=$(kubectl get configmap temple-api-chaos-config -n $NAMESPACE -o jsonpath='{.data.failure-percent}')
    SUCCESS=$(kubectl get configmap temple-api-chaos-config -n $NAMESPACE -o jsonpath='{.data.success-percent}')
    echo "  Failure Rate: ${FAILURE}%"
    echo "  Success Rate: ${SUCCESS}%"
    echo ""
    
    echo -e "${YELLOW}Next Steps:${NC}"
    echo "  1. Run './test-chaos.sh' to test the chaos injection"
    echo "  2. Open Kiali to visualize traffic: 'make kiali'"
    echo "  3. Adjust failure rate: 'make set-chaos-80' or 'make set-chaos-30'"
    echo "  4. View logs: 'make logs-proxy' or 'make logs-app'"
    echo ""
}

main() {
    clear
    
    echo -e "${BLUE}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                                                                    â•‘"
    echo "â•‘         Istio Chaos Testing - Quick Setup                         â•‘"
    echo "â•‘         For Temple API Service                                    â•‘"
    echo "â•‘                                                                    â•‘"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo -e "${NC}"
    echo ""
    
    print_warning "This script will:"
    echo "  1. Enable Istio injection for temple-stack namespace"
    echo "  2. Restart deployments to inject Istio sidecars"
    echo "  3. Apply chaos configuration (60% failure rate)"
    echo "  4. Run initial tests"
    echo ""
    
    read -p "Continue? [Y/n]: " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]] && [[ ! -z $REPLY ]]; then
        print_info "Setup cancelled"
        exit 0
    fi
    
    check_prerequisites
    enable_istio_injection
    restart_deployments
    verify_sidecars
    apply_chaos_config
    make_scripts_executable
    update_etc_hosts
    
    # Wait a bit for configuration to propagate
    print_info "Waiting for configuration to propagate..."
    sleep 5
    
    run_initial_test
    show_summary
    
    echo ""
    print_success "ğŸ‰ Setup complete! Happy chaos testing!"
    echo ""
}

main "$@"
--- FILE: ./test-chaos.sh ---
#!/bin/bash

# ============================================
# Chaos Testing Script for Temple API
# ============================================

set -e

# Configuration
TOTAL=${1:-100}  # Default 100 requests, can be overridden
URL="http://temple-api.local/api/users"
NAMESPACE="temple-stack"

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Counters
SUCCESS=0
FAILURES=0
declare -A STATUS_CODES

# Get expected failure rate from ConfigMap
EXPECTED_FAILURE=$(kubectl get configmap temple-api-chaos-config -n $NAMESPACE -o jsonpath='{.data.failure-percent}' 2>/dev/null || echo "60")
EXPECTED_SUCCESS=$(kubectl get configmap temple-api-chaos-config -n $NAMESPACE -o jsonpath='{.data.success-percent}' 2>/dev/null || echo "40")

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘         Temple API Chaos Testing                             â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo -e "${BLUE}Configuration:${NC}"
echo "  Target URL:        $URL"
echo "  Total Requests:    $TOTAL"
echo "  Expected Failure:  ${EXPECTED_FAILURE}%"
echo "  Expected Success:  ${EXPECTED_SUCCESS}%"
echo ""
echo -e "${BLUE}Running test...${NC}"
echo ""

# Progress bar function
progress_bar() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local completed=$((width * current / total))
    
    printf "\rProgress: ["
    for ((i=0; i<completed; i++)); do printf "â–ˆ"; done
    for ((i=completed; i<width; i++)); do printf " "; done
    printf "] %3d%% (%d/%d)" $percentage $current $total
}

# Run tests
echo -n "Testing: "
for i in $(seq 1 $TOTAL); do
    STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL" 2>/dev/null || echo "000")
    
    # Count status codes
    STATUS_CODES[$STATUS]=$((${STATUS_CODES[$STATUS]:-0} + 1))
    
    if [ "$STATUS" == "200" ]; then
        SUCCESS=$((SUCCESS + 1))
        echo -n "."
    else
        FAILURES=$((FAILURES + 1))
        echo -n "x"
    fi
    
    # New line every 50 requests
    if [ $((i % 50)) -eq 0 ]; then
        echo ""
        echo -n "         "
    fi
    
    # Small delay between requests
    sleep 0.05
done

echo ""
echo ""

# Calculate percentages
SUCCESS_PERCENT=$((SUCCESS * 100 / TOTAL))
FAILURE_PERCENT=$((FAILURES * 100 / TOTAL))

# Display results
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                     Test Results                             â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

echo -e "${BLUE}Summary:${NC}"
echo "  Total Requests:    $TOTAL"
echo -e "  ${GREEN}Successful:${NC}        $SUCCESS (${SUCCESS_PERCENT}%)"
echo -e "  ${RED}Failed:${NC}            $FAILURES (${FAILURE_PERCENT}%)"
echo ""

echo -e "${BLUE}Status Code Distribution:${NC}"
for code in "${!STATUS_CODES[@]}"; do
    count=${STATUS_CODES[$code]}
    percent=$((count * 100 / TOTAL))
    
    if [ "$code" == "200" ]; then
        echo -e "  ${GREEN}$code:${NC} $count requests ($percent%)"
    elif [ "$code" == "503" ]; then
        echo -e "  ${RED}$code:${NC} $count requests ($percent%)"
    else
        echo -e "  ${YELLOW}$code:${NC} $count requests ($percent%)"
    fi
done
echo ""

# Compare with expected values
echo -e "${BLUE}Expected vs Actual:${NC}"

SUCCESS_DIFF=$((SUCCESS_PERCENT - EXPECTED_SUCCESS))
FAILURE_DIFF=$((FAILURE_PERCENT - EXPECTED_FAILURE))

if [ ${SUCCESS_DIFF#-} -le 10 ]; then
    echo -e "  Success Rate:   ${GREEN}âœ“ Within tolerance${NC} (Expected: ${EXPECTED_SUCCESS}%, Actual: ${SUCCESS_PERCENT}%)"
else
    echo -e "  Success Rate:   ${YELLOW}âš  Outside tolerance${NC} (Expected: ${EXPECTED_SUCCESS}%, Actual: ${SUCCESS_PERCENT}%)"
fi

if [ ${FAILURE_DIFF#-} -le 10 ]; then
    echo -e "  Failure Rate:   ${GREEN}âœ“ Within tolerance${NC} (Expected: ${EXPECTED_FAILURE}%, Actual: ${FAILURE_PERCENT}%)"
else
    echo -e "  Failure Rate:   ${YELLOW}âš  Outside tolerance${NC} (Expected: ${EXPECTED_FAILURE}%, Actual: ${FAILURE_PERCENT}%)"
fi
echo ""

# Visual representation
echo -e "${BLUE}Visual Distribution:${NC}"
echo -n "  ["

# Calculate bar segments
success_bars=$((SUCCESS * 50 / TOTAL))
failure_bars=$((FAILURES * 50 / TOTAL))

for ((i=0; i<success_bars; i++)); do echo -n "${GREEN}â–ˆ${NC}"; done
for ((i=0; i<failure_bars; i++)); do echo -n "${RED}â–ˆ${NC}"; done

echo "]"
echo ""

# Recommendations
if [ $FAILURE_PERCENT -gt 70 ]; then
    echo -e "${YELLOW}âš ï¸  High failure rate detected!${NC}"
    echo "   This may impact user experience."
    echo "   Consider reducing failure percentage."
elif [ $FAILURE_PERCENT -lt 10 ]; then
    echo -e "${GREEN}âœ“ Low failure rate${NC}"
    echo "  System is stable with minimal chaos."
fi

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                   Test Complete                              â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Export results to file
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
RESULT_FILE="chaos-test-results-${TIMESTAMP}.txt"

cat > "$RESULT_FILE" <<EOF
Chaos Test Results - $(date)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Configuration:
  Target URL:        $URL
  Total Requests:    $TOTAL
  Expected Failure:  ${EXPECTED_FAILURE}%
  Expected Success:  ${EXPECTED_SUCCESS}%

Results:
  Successful:        $SUCCESS (${SUCCESS_PERCENT}%)
  Failed:            $FAILURES (${FAILURE_PERCENT}%)

Status Codes:
$(for code in "${!STATUS_CODES[@]}"; do
    echo "  $code: ${STATUS_CODES[$code]} ($(( ${STATUS_CODES[$code]} * 100 / TOTAL ))%)"
done)

Comparison:
  Success: Expected ${EXPECTED_SUCCESS}%, Got ${SUCCESS_PERCENT}% (Diff: ${SUCCESS_DIFF}%)
  Failure: Expected ${EXPECTED_FAILURE}%, Got ${FAILURE_PERCENT}% (Diff: ${FAILURE_DIFF}%)
EOF

echo -e "${BLUE}Results saved to: ${RESULT_FILE}${NC}"
echo ""
--- FILE: ./istio-monitoring-ingress.yaml ---
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: monitoring-gateway
  namespace: istio-system
spec:
  selector:
    istio: ingressgateway
  servers:
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
        - "kiali.local"
        - "jaeger.local"
        - "prometheus.local"
        - "grafana.local"
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: kiali-vs
  namespace: istio-system
spec:
  hosts:
    - "kiali.local"
  gateways:
    - monitoring-gateway
  http:
    - route:
        - destination:
            host: kiali.istio-system.svc.cluster.local
            port:
              number: 20001
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: jaeger-vs
  namespace: istio-system
spec:
  hosts:
    - "jaeger.local"
  gateways:
    - monitoring-gateway
  http:
    - route:
        - destination:
            host: tracing.istio-system.svc.cluster.local
            port:
              number: 80
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: prometheus-vs
  namespace: istio-system
spec:
  hosts:
    - "prometheus.local"
  gateways:
    - monitoring-gateway
  http:
    - route:
        - destination:
            host: prometheus.istio-system.svc.cluster.local
            port:
              number: 9090
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: grafana-vs
  namespace: istio-system
spec:
  hosts:
    - "grafana.local"
  gateways:
    - monitoring-gateway
  http:
    - route:
        - destination:
            host: grafana.istio-system.svc.cluster.local
            port:
              number: 3000

